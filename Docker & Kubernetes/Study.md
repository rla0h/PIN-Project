[책제목] 쿠버네티스 완벽 가이드 
======================
> 저자 마사야 아오야마
> 박상욱 옮김

# 1 도커 복습과 Hello, Kubernetes
## 1.1 도커 복습
[**도커**](Docker)는 컨테이너를 실행하기 위한 실행 환경(컴테이너 런타임) 및 툴킷이다.
* 도커 컨테이너 설계
* 도커 파일 작성법
* 도커 이미지 빌드
* 도커 레지스트리로 이미지 푸시

### 1.1.1 도커 컨테이너란?
* 도커 컨테이너는 도커 이미지를 기반으로 실행되는 프로세스
* 환경의 영향을 받지 않고 다양한 환경에서 컨테이너를 기동시킬 수 있기 대문에 이식성이 높음
* 도커 컨테이너는 가상 머신에 비해 '가볍다', '시작과 중지가 빠르다' 등과 같은 장점
* 가상 머신 -> Hyper Visor를 이용하여 게스트 OS 동작
* 도커 컨테이너 -> Host Machine의 커널을 이용하면서 네임스페이스 분리와 cgroups를 이용한 제어를 통해 독립적인 OS와 같은 환경을 만들 수 있음
    * 게스트 OS 기동을 기동을 기다릴 필요 없으므로 프로세스를 빠르게 시작하고 중지 가능

### 1.1.2 도커 컨테이너 설계
* 도커 컨테이너를 생성할 때 주로 주의해야 할점
    * 1 컨테이너 당 1 프로세스
    * 변경 불가능한 인프라(Immutable Infrastructure) 이미지로 생성
    * 경량의 도커 이미지로 생성
    * 실행 계정은 root 이외의 사용자로 한다.

### 1.1.3 도커 파일 작성법
* 도커 이미지는 도커 파일을 기반으로 이미지가 빌드
```
FROM        기반 이미지를 지정
MAINTAINER  컨테이너 이미지 관리자 정보를 기입 (현재는 비추천, 아래 LABEL 명령어를 사용)
LABEL       컨테이너 이미지의 메타데이터를 key:value 형식으로 지정
USER        명령어 실행 계정 지정
WORKDIR     명령어를 실행할 작업 디렉터리 지정
EXPOSE      컨테이너 실행 시 Listen할 포트 지정
COPY        로컬에 있는 파일을 컨테이너로 복사
ADD         로컬에 있는 tar.gz 파일의 압축을 풀고 파일을 컨테이너로 복사
RUN         컨테이너 안에서 명령어를 실행
ENTRYPOINT  컨테이너 기동 시에 실행할 명령어
CMD         컨테이너 기동시에 실행할 명령어 인수
```

### 1.1.4 도커 이미지 빌드
* docker image build 명령어를 사용하여 이미지를 빌드
    * -t 옵션으로 이미지의 이름과 태그를 지정
    * 태그에는 생성하는 도커 이미지의 버전을 지정하는것이 일반

* 도커 이미지는 docker image ls 명령어로 확인

### 1.1.5 이미지 레이어 통합과 이미지 축소화
* 레이어 마다 같은 파일의 변경이 많은 경우
    * docker image build 시 --squash 옵션을 사용
    * 최종 파일 상태를 가진 한 개의 레이어에 하나로 합쳐지므로 컨테이너 이미지를 축소할 수 있다.

### 1.1.6 도커 레지스트리로 이미지 업로드

### 1.1.7 컨테이너 가동
* docker container run 명령어를 사용하여 컨테이너 가동

# 2장 왜 쿠버네티스가 필요할까?
## 2.1 쿠버네티스란?
* 쿠버네티스는 컨테이너화된 애플리케이션의 배포, 확장 등을 관리하는 것을 자동화 하기 위한 플랫폼

## 2.3 쿠버네티스를 사용하면 무엇을 할 수 있을까?
* 여러 쿠버네티스 노드 관리
* 컨테이너 스케줄링
* 롤링 업데이트
* 스케일링/오토 스케일링
* 컨테이너 모니터링
* 자동화된 복구
* 서비스 디스커버리
* 로드 밸런싱
* 데이터 관리
* 워크로드 관리
* 로그 관리
* 선언적 코드를 사용한 관리
* 그 외 에코시스템과의 연계 및 확장

### 2.3.1 선언적 코드를 사용한 관리(IaC)
* 쿠버네티스는 YAML 형식이나 JSON 형식으로 작성한 선언적 코드(매니패스트)를 통해 배포하는 컨테이너로 주변 리소스를 관리할 수 있어 IaC(Infrastructure as Code)를 구현할 수 있다.
```
apiVersion: apps/v1
kind: Deployment
metadata:
    name: sample-deployment
spec:
    replicas: 3
    selector:
        matchLabels:
            app: sample-app
        template:
            metadata:
                labels:
                    app: sample-app
            spec:
                containers:
                    - name: nginx-container
                        image: nginx:1.16
```

### 2.3.2 스케일링/오토 스케일링
* 쿠버네티스는 컨테이너 클러스터(쿠버네티스 클러스터)를 구성하여 여러 쿠버네티스 노드를 관리
* 컨테이너 이미지를 기반으로 쿠버네티스 위에 컨테이너를 배포할 때 같은 컨테이너 이미지를 기반으로 한 여러 컨테이너(레플리카)를 배포하면 부하 분산 및 다중화 구조를 만들 수 있다.
* 또한, 부하에 따라서 컨테이너 레플리카 수를 자동으로 늘리거나 줄일(오토 스케일링) 수도 있다.

### 2.3.3 스케줄링
* 컨테이너를 쿠버네티스 노드에 배포할 때 어떤 쿠버네티스 노드에 배포할 것인지를 결정하는 '스케줄링'
* 어피니티(Affinity)와 안티어피니티(Anti-Affinity) 기능을 사용하여 컨테이너화된 애플리케이션 워크로드의 특징이나 쿠버네티스 노드의 성능을 기준으로 스케줄링 할 수 있다.

### 2.3.4 리소스 관리
* 쿠버네티스 노드의 CPU나 메모리의 여유 리소스 상태에 따라 스케줄링되기 때문에 사용자는 어떤 쿠버네티스 노드에 컨테이너를 배치할지 관리할 필요 X
* 리소스 사용 상태에 따라 클러스터 오토 스케일링 기능으로 쿠버네티스 클러스터의 쿠버네티스 노드도 자동으로 추가하거나 삭제 가능

### 2.3.5 자동화된 복구
* 다중화(fault tolerant) 관점에서는 쿠버네티스의 중요한 콘셉트 중 하나인 자동화된 복구 기능
* 쿠버네티스는 표준으로 컨테이너 프로세스를 모니터링하고 프로세스 정지를 감지하면 다시 컨테이너 스케줄링을 실행하여 컨테이너를 자동으로 재배포
* 클러스터 노드에 장애가 발생하거나 노들르 축출했을 경우 그 노드의 컨테이너가 사라진다 하더라도 서비스에 영향없이 자동 복구

### 2.3.6 로드 밸런싱과 서비스 디스커버리
* 여러대로 구성된 애플리케이션을 하나의 애플리케이션으로 사용자에게 보여주고 접속시키려면 사용자에게 목적지가 되는 여러 대로 구성된 엔드포인트를 준비해야한다.
* 쿠버네티스는 로드 밸런서 기능(서비스(Service) 나 인그레스(Ingress))을 제공하고 있으며 사전에 정의한 조건과 일치하는 컨테이너 그룹에 라우팅하는 엔드포인트를 할당할 수 있다.
* 컨테이너를 확장할 때 엔드포인트가 되는 서비스에 컨테이너의 자동 등록과 삭제, 컨테이너 장애 시 분리, 컨테이너 롤링 업데이트 시 필요한 사전 분리 작업도 자동으로 실행
* 서비스 디스커버리 사용 가능
* 컨테이너를 사용하여 시스템을 구축하는 경우에는 기능별로 독립된 작은 규모의 애플리케이션을 연계하여 시스템을 구현하는 '마이크로서비스 아키텍쳐'를 선택하는것이 일반적
* 서비스에 서비스 디스커버리 기능이 있어 각각의 마이크로서비스가 정의된 복수의 매니페스트를 이용하여 시스템 전체를 쉽게 연계할 수 있다.

### 2.3.7 데이터 관리
* 쿠버네티스는 백엔드 데이터 스토어로 etcd를 채용
    * etcd는 클러스터를 구성하여 이중화가 가능하고 컨테이너나 서비스의 매니페스트 파일도 이중화 구조로 저장
    * 쿠버네티스는 컨테이너가 사용하는 설정 파일이나 인증 정보 등의 데이터를 저장하는 구조도 가지고 있음
        * 컨테이너 공통 설정이나 애플리케이션에서 사용되는 데이터베이스 인증 정보 등을 안전하고 이중화된 상태로 쿠버네티스에서 집중적으로 관리
* 쿠버네티스는 독립적으로 하나의 플랫폼으로 사용할 수 있지만 외부 에코시스템과의 연계도 활발히 이루어지고 있다.
    * 쿠버네티스를 지원하는 미들웨어
        * Ansible: 쿠버네티스에 컨테이너 배포
        * Apache Ignite: 쿠버네티스 서비스 디스커버리를 사용한 클러스터 생성과 스케일링
        * Fluentd: 쿠버네티스에 컨테이너 로그 전송
        * 그외 다수
* 쿠버네티스는 기능을 확장할 수 있는 여러 구조를 가지고 있으며 자체 기능을 추가하거나 쿠버네티스 자체를 프레임워크로 자체 플랫폼을 구현하여 사용할 수도 있다.

# 3장 쿠버네티스 환경 선택
## 3.1 쿠버네티스 환경의 종류
* 쿠버네티스는 여러 플랫폼 환경에서 클러스터를 구성하여 사용할 수 있다.
    * 로컬 쿠버네티스
        * 물리 머신 한 대에 구축하여 사용
        * 미니큐브(Minikube)
        * Docker Desktop for Mac/Windows
        * kind(Kubernets in Docker)
    * 쿠버네티스 구축 도구
        * 도구를 사용하여 온프레미스/클라우드에 클러스터를 구축하여 사용
        * 큐브어드민(kubeadm)
        * 랜처(Rancher)
    * 관리형 쿠버네티스 서비스
        * 퍼블릭 클라우드의 관리형 서비스로 제공하는 클러스터를 사용
        * Google Kubernetes Engine(GKE)
        * Azure Kubernetes Service(AKS)
        * Elastic Kubernetes Service(EKS)

# 4장 API 리소스와 kubectl
## 4.2 쿠버네티스 기초
* 쿠버네티스는 쿠버네티스 마스터와 쿠버네티스 노드로 구성되어 있다.
    * 쿠버네티스 마스터는 API 엔드포인트 제공, 컨테이너 스케줄링, 컨테이너 스케일링 등을 담당하는 노드
    * 쿠버네티스 노드는 이른바 도커 호스트에 해당하며 실제로 컨테이너를 기동시키는 노드
* 쿠버네티스 클러스터를 관리하려면 CLI 도구인 kubectl과 YAML 형식이나 JSON 형식으로 작성된 매니페스트 파일을 사용하여 쿠버네티스 마스터에 '리소스'를 등록
* 매니페스트 파일은 가독성을 고려하여 YAML 형식으로 작성하는 것이 일반적이며 확장자(.yamlm .yml, .json)로 구분
* kubectl 은 매니페스트 파일 정보를 바탕으로 쿠버네티스 마스터가 가진 API 요청을 보내어 쿠버네티스를 관리
> 쿠버네티스 API는 일반적으로 RESTful API로 구현되어 있다.

## 4.3 쿠버네티스와 리소스
* 쿠버네티스를 관리하기 위해 등록하는 '리소스'는 컨테이너의 실행과 로드 밸런서 생성 등 많은 종류가 있다.
    * 워크로드 API 카테고리 : 컨테이너 실행에 관련된 리소스
    * 서비스 API 카테고리 : 컨테이너를 외부에 공개하는 엔드포인트를 제공하는 리소스
    * 컨피그 & 스토리지 API 카테고리 : 설정/기밀 정보/영구 볼륨 등에 관련된 리소스
    * 클러스터 API 카테고리 : 보안이나 쿼터 등에 관련된 리소스
    * 메타데이터 API 카테고리 : 클러스터 내부의 다른 리소스를 관리하기 위한 리소스

### 4.3.1 워크로드 API 카테고리
* 워크로드 API 카테고리는 클러스터 위에서 컨테이너를 기동하기 위해 사용되는 리소스
    * 내부적으로 사용되는 것을 제외하고 사용자가 직접 관리할 수 있는 것으로 총 여덟가지 종류의 워크로드 리소스가 있음
        * 파드
        * 레플리케이션 컨트롤러
        * 레플리카셋
        * 디플로이먼트
        * 데몬셋
        * 스테이트풀셋
        * 잡
        * 크론잡

### 4.3.2 서비스 API 카테고리
* 서비스 API 카테고리는 컨테이너 서비스 디스커버리와 클러스터 외부에서도 접속이 가능한 엔드포인트 등을 제공하는 리소스
    * 내부적으로 사용되는 것을 제외하고 사용자가 직접 관리할 수 있는 리소스로 서비스와 인그레스라는 두 종류의 서비스 API 카테고리가 있다.
        * 서비스
            * ClusterIP
            * ExternalIP
            * NodePort
            * LoadBalancer
            * Headless
            * ExternalName
            * None-Selector
        * 인그레스

### 4.3.3 컨피그 & 스토리지 API 카테고리
* 컨피그 & 스토리지 API 카테고리는 설정과 기밀 데이터를 컨테이너에 담거나 영구 볼륨을 제공하는 리소스
    * 시크릿과 컨피그맵은 모두 key-value 형태의 데이터 구조로 되어 있음
    * 저장할 데이터가 기밀데이터인지 일반적인 설정 정보인지에 따라 구분
        * 시크릿
        * 컨피그맵
        * 영구 볼륨 클레임
            > 컨테이너에서 영구 볼륨을 요청할 때 사용

### 4.3.4 클러스터 API 카테고리
* 클러스터 API 카테고리는 클러스터 자체 동작을 정의하는 리소스
    * 보안 관련 설정이나 정책, 클러스터 관리성을 향상시키는 기능을 위한 리소스 등 여러 리소스가 있다.
        * 노드(Node)
        * Namespace
        * PersistentVolume
        * ResourceQuota
        * ServiceAccount
        * Role
        * ClusterRole
        * RoleBinding
        * ClusterRoleBinding
        * NetworkPolicy
### 4.3.5 메타데이터 API 카테고리
* 메타데이터 API 카테고리는 클러스터 내부의 다른 리소스 동작을 제어하기 위한 리소스
> 파드를 오토 스케일링 시키기 위해 사용하는 HorizontalPodAutoscaler(HPA)는 디플로이먼트 리소스를 조작해 레플리카 수를 변경함으로써 오토 스케일링을 구현 
   * LimitRange
   * HorizontalPodAutoscaler(HPA)
   * PodDisruptionBudget(PDB)
   * 커스텀 리소스 데피니션(CustomResourceDefinition)

## 4.4 네임스페이스로 가상적인 클러스터 분리
* Namespace : 가상적인 쿠버네티스 클러스터 분리 기능
* 하나의 쿠버네티스 클러스터를 여러팀에서 사용하거나 서비스 환경/스테이징 환경/개발 환경으로 구분하는 경우 사용
* 기본 설정에는 4가지 네임스페이스 생성
    * kube-system
        * 쿠버네티스 클러스터 구성 요소와 애드온이 배포될 네임스페이스
    * kube-public
        * 모든 사용자가 사용할 수 있는 컨피그맵 등을 배치하는 네임스페이스
    * kube-node-lease
        * 노드 하트비트 정보가 저장된 네임스페이스
    * default
        * 기본 네임스페이스
    
* 네임스페이스 분리 범위에 대해서는 권한 분리 관점에서 마이크로서비스를 개발하는 팀마다 분리하는 것이 좋음.
* 서비스 환경/스테이징 환경/개발 환경을 네임스페이스로 분리하는 시스템도 있지만, 저자는 네임스페이스가 아닌 클러스터별로 나눠야 한다고 생각
    * WHY?
        * 클러스터 업그레이드 시 동시에 모든 환경에서 장애가 발생할 가능성이 있음
        * 네임스페이스 명명 규칙이 prd-ns1/stg-ns1처럼 되면 매니페스트 재사용성이 현저하게 저하
        > 클러스터를 분리하면 각 환경에서 같은 네임스페이스 이름을 사용할 수 있기 때문에 완전히 같은 매니페스트를 재사용 할 수 있다.
        * 서비스 이름 해석 시 SERVICE, prd-ns1, svc, cluster, local 등의 다른 목적지에 통신을 해야함

## 4.5 커맨드 라인 인터페이스(CLI) 도구 kubectl
* 쿠버네티스 클러스터 조작은 보통 마스터의 API를 통해 이루어진다.
* 수동으로 조작하는 경우에는 CLI 도구인 'kubectl'을 사용하는것이 일반적

### 4.5.1 인증 정보와 컨텍스트(config)
* kubectl이 쿠버네티스 마스터와 통신할 때는 접속 대상의 서버 정보, 인증 정보 등이 필요
* kubectl은 kubeconfig(기본 위치는 ~/.kube/config)에 쓰여 있는 정보를 사용하여 접속
* kubeconfig도 매니페스트와 동일한 형식으로 작성
```
apiVersion: v1
kind: Config
preferences: {}
clusters: # 접속 대상 클러스터
    - name: sample-cluster
      cluster:
        server: https://localhost:6443
users: # 인증정보
    - name: sample-user
      user:
        client-certificate-data: LS0tLS1CRUDjTi...
        client-key-data: LS0tLS1CRUdJTi...
contexts: # 접속 대상과 인증 정보 조합
    - name: sample-context
      context:
        cluster: sample-cluster
        namespace: default
        user: sample-user
current-context: sample-context
```
* kubeconfig에 구체적으로 설정이 이루어지는 부분은 clusters/users/contexts 세가지
    * 세 가지 설정 항목은 모두 배열로 되어 있어 여러 대상을 등록 할 수 있다.
